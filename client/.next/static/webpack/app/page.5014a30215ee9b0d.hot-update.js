"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ragApi: function() { return /* binding */ ragApi; },\n/* harmony export */   transcriptApi: function() { return /* binding */ transcriptApi; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   youtubeApi: function() { return /* binding */ youtubeApi; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// API Base URL - adjust this to match your backend\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\n// Generic API request function\nasync function apiRequest(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(API_BASE_URL).concat(endpoint);\n    const config = {\n        ...options,\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        }\n    };\n    const response = await fetch(url, config);\n    if (!response.ok) {\n        throw new Error(\"API request failed: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    return response.json();\n}\n// YouTube API\nconst youtubeApi = {\n    searchVideos: async function(query) {\n        let maxResults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        return apiRequest(\"/api/youtube/search?q=\".concat(encodeURIComponent(query), \"&max_results=\").concat(maxResults));\n    }\n};\n// Transcript API\nconst transcriptApi = {\n    getTranscript: async (videoId)=>{\n        return apiRequest(\"/api/transcripts/transcript-supadata/\".concat(videoId));\n    }\n};\n// RAG API\nconst ragApi = {\n    processTranscript: async (videoId, request)=>{\n        return apiRequest(\"/api/rag/process/\".concat(videoId), {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    },\n    generateResponse: async (videoId, request)=>{\n        return apiRequest(\"/api/rag/generate/\".concat(videoId), {\n            method: \"POST\",\n            body: JSON.stringify(request)\n        });\n    }\n};\n// Utility functions\nconst utils = {\n    // Format duration in seconds to MM:SS or HH:MM:SS format\n    formatDuration: (seconds)=>{\n        if (isNaN(seconds) || seconds < 0) return \"0:00\";\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor(seconds % 3600 / 60);\n        const secs = Math.floor(seconds % 60);\n        if (hours > 0) {\n            return \"\".concat(hours, \":\").concat(minutes.toString().padStart(2, \"0\"), \":\").concat(secs.toString().padStart(2, \"0\"));\n        }\n        return \"\".concat(minutes, \":\").concat(secs.toString().padStart(2, \"0\"));\n    },\n    // Format timestamp in seconds to MM:SS or HH:MM:SS format\n    formatTimestamp: (seconds)=>{\n        return utils.formatDuration(seconds);\n    },\n    // Truncate text to specified length with ellipsis\n    truncateText: (text, maxLength)=>{\n        if (!text || text.length <= maxLength) return text;\n        return text.substring(0, maxLength).trim() + \"...\";\n    },\n    // Convert seconds to human readable format (e.g., \"2h 30m\", \"45m\", \"30s\")\n    formatDurationHuman: (seconds)=>{\n        if (isNaN(seconds) || seconds < 0) return \"0s\";\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor(seconds % 3600 / 60);\n        const secs = Math.floor(seconds % 60);\n        const parts = [];\n        if (hours > 0) parts.push(\"\".concat(hours, \"h\"));\n        if (minutes > 0) parts.push(\"\".concat(minutes, \"m\"));\n        if (secs > 0 && hours === 0) parts.push(\"\".concat(secs, \"s\"));\n        return parts.join(\" \") || \"0s\";\n    },\n    // Validate YouTube URL and extract video ID\n    extractVideoId: (url)=>{\n        const regex = /(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/;\n        const match = url.match(regex);\n        return match ? match[1] : null;\n    },\n    // Format view count with appropriate units (K, M, B)\n    formatViewCount: (count)=>{\n        if (count < 1000) return count.toString();\n        if (count < 1000000) return \"\".concat((count / 1000).toFixed(1), \"K\");\n        if (count < 1000000000) return \"\".concat((count / 1000000).toFixed(1), \"M\");\n        return \"\".concat((count / 1000000000).toFixed(1), \"B\");\n    },\n    // Parse ISO date to readable format\n    formatDate: (dateString)=>{\n        try {\n            const date = new Date(dateString);\n            return date.toLocaleDateString(\"en-US\", {\n                year: \"numeric\",\n                month: \"short\",\n                day: \"numeric\"\n            });\n        } catch (e) {\n            return dateString;\n        }\n    },\n    // Calculate relevance color for search results\n    getRelevanceColor: (relevance)=>{\n        if (relevance >= 0.8) return \"text-green-600\";\n        if (relevance >= 0.6) return \"text-blue-600\";\n        return \"text-gray-600\";\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBU0EsbURBQW1EO0FBQ25ELE1BQU1BLGVBQWVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUFFeEQsK0JBQStCO0FBQy9CLGVBQWVDLFdBQWNDLFFBQWdCO1FBQUVDLFVBQUFBLGlFQUF1QixDQUFDO0lBQ3JFLE1BQU1DLE1BQU0sR0FBa0JGLE9BQWZMLGNBQXdCLE9BQVRLO0lBRTlCLE1BQU1HLFNBQXNCO1FBQzFCLEdBQUdGLE9BQU87UUFDVkcsU0FBUztZQUNQLGdCQUFnQjtZQUNoQixHQUFHSCxRQUFRRyxPQUFPO1FBQ3BCO0lBQ0Y7SUFFQSxNQUFNQyxXQUFXLE1BQU1DLE1BQU1KLEtBQUtDO0lBRWxDLElBQUksQ0FBQ0UsU0FBU0UsRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTSx1QkFBMENILE9BQW5CQSxTQUFTSSxNQUFNLEVBQUMsS0FBdUIsT0FBcEJKLFNBQVNLLFVBQVU7SUFDL0U7SUFFQSxPQUFPTCxTQUFTTSxJQUFJO0FBQ3RCO0FBRUEsY0FBYztBQUNQLE1BQU1DLGFBQWE7SUFDeEJDLGNBQWMsZUFBT0M7WUFBZUMsOEVBQXFCO1FBQ3ZELE9BQU9oQixXQUFrQyx5QkFBa0VnQixPQUF6Q0MsbUJBQW1CRixRQUFPLGlCQUEwQixPQUFYQztJQUM3RztBQUNGLEVBQUU7QUFFRixpQkFBaUI7QUFDVixNQUFNRSxnQkFBZ0I7SUFDM0JDLGVBQWUsT0FBT0M7UUFDcEIsT0FBT3BCLFdBQTZDLHdDQUFnRCxPQUFSb0I7SUFDOUY7QUFDRixFQUFFO0FBRUYsVUFBVTtBQUNILE1BQU1DLFNBQVM7SUFDcEJDLG1CQUFtQixPQUFPRixTQUFpQkc7UUFDekMsT0FBT3ZCLFdBQStCLG9CQUE0QixPQUFSb0IsVUFBVztZQUNuRUksUUFBUTtZQUNSQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNKO1FBQ3ZCO0lBQ0Y7SUFFQUssa0JBQWtCLE9BQU9SLFNBQWlCRztRQUN4QyxPQUFPdkIsV0FBZ0MscUJBQTZCLE9BQVJvQixVQUFXO1lBQ3JFSSxRQUFRO1lBQ1JDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0o7UUFDdkI7SUFDRjtBQUNGLEVBQUU7QUFFRixvQkFBb0I7QUFDYixNQUFNTSxRQUFRO0lBQ25CLHlEQUF5RDtJQUN6REMsZ0JBQWdCLENBQUNDO1FBQ2YsSUFBSUMsTUFBTUQsWUFBWUEsVUFBVSxHQUFHLE9BQU87UUFFMUMsTUFBTUUsUUFBUUMsS0FBS0MsS0FBSyxDQUFDSixVQUFVO1FBQ25DLE1BQU1LLFVBQVVGLEtBQUtDLEtBQUssQ0FBQyxVQUFXLE9BQVE7UUFDOUMsTUFBTUUsT0FBT0gsS0FBS0MsS0FBSyxDQUFDSixVQUFVO1FBRWxDLElBQUlFLFFBQVEsR0FBRztZQUNiLE9BQU8sR0FBWUcsT0FBVEgsT0FBTSxLQUEwQ0ksT0FBdkNELFFBQVFFLFFBQVEsR0FBR0MsUUFBUSxDQUFDLEdBQUcsTUFBSyxLQUFvQyxPQUFqQ0YsS0FBS0MsUUFBUSxHQUFHQyxRQUFRLENBQUMsR0FBRztRQUN4RjtRQUVBLE9BQU8sR0FBY0YsT0FBWEQsU0FBUSxLQUFvQyxPQUFqQ0MsS0FBS0MsUUFBUSxHQUFHQyxRQUFRLENBQUMsR0FBRztJQUNuRDtJQUVBLDBEQUEwRDtJQUMxREMsaUJBQWlCLENBQUNUO1FBQ2hCLE9BQU9GLE1BQU1DLGNBQWMsQ0FBQ0M7SUFDOUI7SUFFQSxrREFBa0Q7SUFDbERVLGNBQWMsQ0FBQ0MsTUFBY0M7UUFDM0IsSUFBSSxDQUFDRCxRQUFRQSxLQUFLRSxNQUFNLElBQUlELFdBQVcsT0FBT0Q7UUFDOUMsT0FBT0EsS0FBS0csU0FBUyxDQUFDLEdBQUdGLFdBQVdHLElBQUksS0FBSztJQUMvQztJQUVBLDBFQUEwRTtJQUMxRUMscUJBQXFCLENBQUNoQjtRQUNwQixJQUFJQyxNQUFNRCxZQUFZQSxVQUFVLEdBQUcsT0FBTztRQUUxQyxNQUFNRSxRQUFRQyxLQUFLQyxLQUFLLENBQUNKLFVBQVU7UUFDbkMsTUFBTUssVUFBVUYsS0FBS0MsS0FBSyxDQUFDLFVBQVcsT0FBUTtRQUM5QyxNQUFNRSxPQUFPSCxLQUFLQyxLQUFLLENBQUNKLFVBQVU7UUFFbEMsTUFBTWlCLFFBQVEsRUFBRTtRQUNoQixJQUFJZixRQUFRLEdBQUdlLE1BQU1DLElBQUksQ0FBQyxHQUFTLE9BQU5oQixPQUFNO1FBQ25DLElBQUlHLFVBQVUsR0FBR1ksTUFBTUMsSUFBSSxDQUFDLEdBQVcsT0FBUmIsU0FBUTtRQUN2QyxJQUFJQyxPQUFPLEtBQUtKLFVBQVUsR0FBR2UsTUFBTUMsSUFBSSxDQUFDLEdBQVEsT0FBTFosTUFBSztRQUVoRCxPQUFPVyxNQUFNRSxJQUFJLENBQUMsUUFBUTtJQUM1QjtJQUVBLDRDQUE0QztJQUM1Q0MsZ0JBQWdCLENBQUNoRDtRQUNmLE1BQU1pRCxRQUFRO1FBQ2QsTUFBTUMsUUFBUWxELElBQUlrRCxLQUFLLENBQUNEO1FBQ3hCLE9BQU9DLFFBQVFBLEtBQUssQ0FBQyxFQUFFLEdBQUc7SUFDNUI7SUFFQSxxREFBcUQ7SUFDckRDLGlCQUFpQixDQUFDQztRQUNoQixJQUFJQSxRQUFRLE1BQU0sT0FBT0EsTUFBTWpCLFFBQVE7UUFDdkMsSUFBSWlCLFFBQVEsU0FBUyxPQUFPLEdBQTZCLE9BQTFCLENBQUNBLFFBQVEsSUFBRyxFQUFHQyxPQUFPLENBQUMsSUFBRztRQUN6RCxJQUFJRCxRQUFRLFlBQVksT0FBTyxHQUFnQyxPQUE3QixDQUFDQSxRQUFRLE9BQU0sRUFBR0MsT0FBTyxDQUFDLElBQUc7UUFDL0QsT0FBTyxHQUFtQyxPQUFoQyxDQUFDRCxRQUFRLFVBQVMsRUFBR0MsT0FBTyxDQUFDLElBQUc7SUFDNUM7SUFFQSxvQ0FBb0M7SUFDcENDLFlBQVksQ0FBQ0M7UUFDWCxJQUFJO1lBQ0YsTUFBTUMsT0FBTyxJQUFJQyxLQUFLRjtZQUN0QixPQUFPQyxLQUFLRSxrQkFBa0IsQ0FBQyxTQUFTO2dCQUN0Q0MsTUFBTTtnQkFDTkMsT0FBTztnQkFDUEMsS0FBSztZQUNQO1FBQ0YsRUFBRSxVQUFNO1lBQ04sT0FBT047UUFDVDtJQUNGO0lBRUEsK0NBQStDO0lBQy9DTyxtQkFBbUIsQ0FBQ0M7UUFDbEIsSUFBSUEsYUFBYSxLQUFLLE9BQU87UUFDN0IsSUFBSUEsYUFBYSxLQUFLLE9BQU87UUFDN0IsT0FBTztJQUNUO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS50cz8yZmFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFlvdVR1YmVTZWFyY2hSZXNwb25zZSxcbiAgVHJhbnNjcmlwdFdpdGhUaW1lc3RhbXBzUmVzcG9uc2UsXG4gIFJBR1Byb2Nlc3NSZXF1ZXN0LFxuICBSQUdQcm9jZXNzUmVzcG9uc2UsXG4gIFJBR0dlbmVyYXRlUmVxdWVzdCxcbiAgUkFHR2VuZXJhdGVSZXNwb25zZSxcbn0gZnJvbSAnQC90eXBlcy9hcGknO1xuXG4vLyBBUEkgQmFzZSBVUkwgLSBhZGp1c3QgdGhpcyB0byBtYXRjaCB5b3VyIGJhY2tlbmRcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCc7XG5cbi8vIEdlbmVyaWMgQVBJIHJlcXVlc3QgZnVuY3Rpb25cbmFzeW5jIGZ1bmN0aW9uIGFwaVJlcXVlc3Q8VD4oZW5kcG9pbnQ6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fSk6IFByb21pc2U8VD4ge1xuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xuICBcbiAgY29uc3QgY29uZmlnOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgY29uZmlnKTtcbiAgXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbi8vIFlvdVR1YmUgQVBJXG5leHBvcnQgY29uc3QgeW91dHViZUFwaSA9IHtcbiAgc2VhcmNoVmlkZW9zOiBhc3luYyAocXVlcnk6IHN0cmluZywgbWF4UmVzdWx0czogbnVtYmVyID0gMTApOiBQcm9taXNlPFlvdVR1YmVTZWFyY2hSZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFlvdVR1YmVTZWFyY2hSZXNwb25zZT4oYC9hcGkveW91dHViZS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9Jm1heF9yZXN1bHRzPSR7bWF4UmVzdWx0c31gKTtcbiAgfSxcbn07XG5cbi8vIFRyYW5zY3JpcHQgQVBJXG5leHBvcnQgY29uc3QgdHJhbnNjcmlwdEFwaSA9IHtcbiAgZ2V0VHJhbnNjcmlwdDogYXN5bmMgKHZpZGVvSWQ6IHN0cmluZyk6IFByb21pc2U8VHJhbnNjcmlwdFdpdGhUaW1lc3RhbXBzUmVzcG9uc2U+ID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdDxUcmFuc2NyaXB0V2l0aFRpbWVzdGFtcHNSZXNwb25zZT4oYC9hcGkvdHJhbnNjcmlwdHMvdHJhbnNjcmlwdC1zdXBhZGF0YS8ke3ZpZGVvSWR9YCk7XG4gIH0sXG59O1xuXG4vLyBSQUcgQVBJXG5leHBvcnQgY29uc3QgcmFnQXBpID0ge1xuICBwcm9jZXNzVHJhbnNjcmlwdDogYXN5bmMgKHZpZGVvSWQ6IHN0cmluZywgcmVxdWVzdDogUkFHUHJvY2Vzc1JlcXVlc3QpOiBQcm9taXNlPFJBR1Byb2Nlc3NSZXNwb25zZT4gPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0PFJBR1Byb2Nlc3NSZXNwb25zZT4oYC9hcGkvcmFnL3Byb2Nlc3MvJHt2aWRlb0lkfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXG4gICAgfSk7XG4gIH0sXG5cbiAgZ2VuZXJhdGVSZXNwb25zZTogYXN5bmMgKHZpZGVvSWQ6IHN0cmluZywgcmVxdWVzdDogUkFHR2VuZXJhdGVSZXF1ZXN0KTogUHJvbWlzZTxSQUdHZW5lcmF0ZVJlc3BvbnNlPiA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3Q8UkFHR2VuZXJhdGVSZXNwb25zZT4oYC9hcGkvcmFnL2dlbmVyYXRlLyR7dmlkZW9JZH1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgIH0pO1xuICB9LFxufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgLy8gRm9ybWF0IGR1cmF0aW9uIGluIHNlY29uZHMgdG8gTU06U1Mgb3IgSEg6TU06U1MgZm9ybWF0XG4gIGZvcm1hdER1cmF0aW9uOiAoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA8IDApIHJldHVybiAnMDowMCc7XG4gICAgXG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigoc2Vjb25kcyAlIDM2MDApIC8gNjApO1xuICAgIGNvbnN0IHNlY3MgPSBNYXRoLmZsb29yKHNlY29uZHMgJSA2MCk7XG4gICAgXG4gICAgaWYgKGhvdXJzID4gMCkge1xuICAgICAgcmV0dXJuIGAke2hvdXJzfToke21pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBgJHttaW51dGVzfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH0sXG5cbiAgLy8gRm9ybWF0IHRpbWVzdGFtcCBpbiBzZWNvbmRzIHRvIE1NOlNTIG9yIEhIOk1NOlNTIGZvcm1hdFxuICBmb3JtYXRUaW1lc3RhbXA6IChzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiB1dGlscy5mb3JtYXREdXJhdGlvbihzZWNvbmRzKTtcbiAgfSxcblxuICAvLyBUcnVuY2F0ZSB0ZXh0IHRvIHNwZWNpZmllZCBsZW5ndGggd2l0aCBlbGxpcHNpc1xuICB0cnVuY2F0ZVRleHQ6ICh0ZXh0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICBpZiAoIXRleHQgfHwgdGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKS50cmltKCkgKyAnLi4uJztcbiAgfSxcblxuICAvLyBDb252ZXJ0IHNlY29uZHMgdG8gaHVtYW4gcmVhZGFibGUgZm9ybWF0IChlLmcuLCBcIjJoIDMwbVwiLCBcIjQ1bVwiLCBcIjMwc1wiKVxuICBmb3JtYXREdXJhdGlvbkh1bWFuOiAoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA8IDApIHJldHVybiAnMHMnO1xuICAgIFxuICAgIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNlY29uZHMgJSAzNjAwKSAvIDYwKTtcbiAgICBjb25zdCBzZWNzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICAgIFxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgaWYgKGhvdXJzID4gMCkgcGFydHMucHVzaChgJHtob3Vyc31oYCk7XG4gICAgaWYgKG1pbnV0ZXMgPiAwKSBwYXJ0cy5wdXNoKGAke21pbnV0ZXN9bWApO1xuICAgIGlmIChzZWNzID4gMCAmJiBob3VycyA9PT0gMCkgcGFydHMucHVzaChgJHtzZWNzfXNgKTtcbiAgICBcbiAgICByZXR1cm4gcGFydHMuam9pbignICcpIHx8ICcwcyc7XG4gIH0sXG5cbiAgLy8gVmFsaWRhdGUgWW91VHViZSBVUkwgYW5kIGV4dHJhY3QgdmlkZW8gSURcbiAgZXh0cmFjdFZpZGVvSWQ6ICh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHJlZ2V4ID0gLyg/OnlvdXR1YmVcXC5jb21cXC8oPzpbXlxcL10rXFwvLitcXC98KD86dnxlKD86bWJlZCk/KVxcL3wuKls/Jl12PSl8eW91dHVcXC5iZVxcLykoW15cIiY/XFwvXFxzXXsxMX0pLztcbiAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xuICB9LFxuXG4gIC8vIEZvcm1hdCB2aWV3IGNvdW50IHdpdGggYXBwcm9wcmlhdGUgdW5pdHMgKEssIE0sIEIpXG4gIGZvcm1hdFZpZXdDb3VudDogKGNvdW50OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChjb3VudCA8IDEwMDApIHJldHVybiBjb3VudC50b1N0cmluZygpO1xuICAgIGlmIChjb3VudCA8IDEwMDAwMDApIHJldHVybiBgJHsoY291bnQgLyAxMDAwKS50b0ZpeGVkKDEpfUtgO1xuICAgIGlmIChjb3VudCA8IDEwMDAwMDAwMDApIHJldHVybiBgJHsoY291bnQgLyAxMDAwMDAwKS50b0ZpeGVkKDEpfU1gO1xuICAgIHJldHVybiBgJHsoY291bnQgLyAxMDAwMDAwMDAwKS50b0ZpeGVkKDEpfUJgO1xuICB9LFxuXG4gIC8vIFBhcnNlIElTTyBkYXRlIHRvIHJlYWRhYmxlIGZvcm1hdFxuICBmb3JtYXREYXRlOiAoZGF0ZVN0cmluZzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBkYXRlU3RyaW5nO1xuICAgIH1cbiAgfSxcblxuICAvLyBDYWxjdWxhdGUgcmVsZXZhbmNlIGNvbG9yIGZvciBzZWFyY2ggcmVzdWx0c1xuICBnZXRSZWxldmFuY2VDb2xvcjogKHJlbGV2YW5jZTogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICBpZiAocmVsZXZhbmNlID49IDAuOCkgcmV0dXJuICd0ZXh0LWdyZWVuLTYwMCc7XG4gICAgaWYgKHJlbGV2YW5jZSA+PSAwLjYpIHJldHVybiAndGV4dC1ibHVlLTYwMCc7XG4gICAgcmV0dXJuICd0ZXh0LWdyYXktNjAwJztcbiAgfSxcbn07XG4iXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJhcGlSZXF1ZXN0IiwiZW5kcG9pbnQiLCJvcHRpb25zIiwidXJsIiwiY29uZmlnIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImpzb24iLCJ5b3V0dWJlQXBpIiwic2VhcmNoVmlkZW9zIiwicXVlcnkiLCJtYXhSZXN1bHRzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidHJhbnNjcmlwdEFwaSIsImdldFRyYW5zY3JpcHQiLCJ2aWRlb0lkIiwicmFnQXBpIiwicHJvY2Vzc1RyYW5zY3JpcHQiLCJyZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZW5lcmF0ZVJlc3BvbnNlIiwidXRpbHMiLCJmb3JtYXREdXJhdGlvbiIsInNlY29uZHMiLCJpc05hTiIsImhvdXJzIiwiTWF0aCIsImZsb29yIiwibWludXRlcyIsInNlY3MiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZm9ybWF0VGltZXN0YW1wIiwidHJ1bmNhdGVUZXh0IiwidGV4dCIsIm1heExlbmd0aCIsImxlbmd0aCIsInN1YnN0cmluZyIsInRyaW0iLCJmb3JtYXREdXJhdGlvbkh1bWFuIiwicGFydHMiLCJwdXNoIiwiam9pbiIsImV4dHJhY3RWaWRlb0lkIiwicmVnZXgiLCJtYXRjaCIsImZvcm1hdFZpZXdDb3VudCIsImNvdW50IiwidG9GaXhlZCIsImZvcm1hdERhdGUiLCJkYXRlU3RyaW5nIiwiZGF0ZSIsIkRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJnZXRSZWxldmFuY2VDb2xvciIsInJlbGV2YW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});